#include <iostream>
#include <stdlib.h>

void BubleSort(int* mass, int n) // функция сортировки массива методом "пузырька". На вход подается массив и количество элементов в нем
{
	for (int i = 0; i < n - 1; i++) // пробегаемся по массиву (последний элемент не включая, т.к. после сортировки он сам "встанет" на свое место)
	{
		for (int j = (n - 1); j > i; j--) // пробегаемся по массиву в обратном направлении до i, то есть до отсортированной части массива
		{
			if (mass[j - 1] > mass[j]) // если элемент больше следующего (т.к. идем "сверху-вниз"), то меняем элементы местами
			{
				int temp = mass[j - 1];
				mass[j - 1] = mass[j];
				mass[j] = temp;
			}
		}
	}
}

void ExchangeSort(int* mass, int n) // функция сортировки массива методом обмена. На вход подается массив и количество элементов в нем
{
	int min; //вводим переменную для минимального элемента
	for (int i = n - 1; i > 0; i--) // пробегаемся по массиву (последний элемент не включая, т.к. после сортировки он сам "встанет" на свое место)
	{
		min = i; // принимает за минимум каждый раз индекс крайнего правого элемента из неотсортированного массива
		for (int j = i - 1; j >= 0; j--) // пробегаемся по неотсортированному массиву, и если элемент меньше элемента с индексом min, то считаем min равным индексу этого элемента
		{
			if (mass[j] < mass[min])
			{
				min = j;
			}
		}
		int temp = mass[i]; // совершаем обмен крайнего правого элемента и минимального из неотсортированной части массива
		mass[i] = mass[min];
		mass[min] = temp;
	}
}

int main()
{
	setlocale(LC_ALL, "rus"); //объявление русской библиотеки для ввода текста
	int i, n; //вводим переменные для счетчика, количества элементов в массиве
	printf("Введите количество элементов массива: "); //указание, что вводить
	scanf_s("%d", &n); // вводим размер массива
	int* s = (int*)malloc(n * sizeof(int)); //создаем динамический массив (выделяем память под массив размером количество элементов*размер одного элемента в байтах
	for (i = 0; i < n; i++) //считываем в цикле каждый элемент массива с клавиатуры
	{
		scanf_s("%d", &s[i]);
	}
	int max = s[0], p_max = 0, min = s[0], p_min = 0; // вводим переменные для максимального и минимального элементов и их позиций. Принимаем позиции за 0, а элементы за 1 элемент в массиве
	for (i = 0; i < n; i++) //пробегаемся по массиву s, находим индекс последнего минимального элемента
	{
		if (s[i] <= min)
		{
			min = s[i];
			p_min = i;
		}
	}
	for (i = n - 1; i >= 0; i--) //пробегаемся по массиву s в обратном порядке, находим индекс первого (по счету, но в цикле последнего) максимального элемента
	{
		if (s[i] >= max)
		{
			max = s[i];
			p_max = i;
		}
	}
	printf("Индекс первого максимального элемента: %d\nИндекс последнего минимального элемента: %d\nИх разность (%d-%d): %d\n", p_max, p_min, p_min, p_max, p_min - p_max);
	if ((p_min - p_max) % 2 == 0) // если разность четная, то сортируем методом обмена по убыванию, если нет, то методом "пузырька" по возрастанию
	{
		ExchangeSort(s, n);
		printf("Отсортированный массив методом обмена по убыванию: ");
	}
	else
	{
		BubleSort(s, n);
		printf("Отсортированный массив методом пузырька по возрастанию: ");
	}
	for (i = 0; i < n; i++) // выводим отсортированный массив
	{
		printf("%d ", s[i]);
	}
	return 0;
}